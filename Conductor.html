<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI æŒ‡æŒ¥å®¶ - ç²¾å‡†å¯¹é½ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Segoe UI', monospace; }
        
        /* 1. è§†é¢‘èƒŒæ™¯å±‚ */
        #video-element {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; 
            z-index: 0;
            /* å…³é”®ï¼šæ°´å¹³ç¿»è½¬ï¼Œè¥é€ é•œå­æ•ˆæœ */
            transform: scaleX(-1); 
            filter: grayscale(100%) contrast(1.2) brightness(0.5); 
            transition: opacity 1s;
        }

        /* 2. 3D æ¸²æŸ“å±‚ */
        #canvas-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; pointer-events: none;
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
        }

        /* UI æ ·å¼ä¿æŒä¸å˜ */
        #hud-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.5); padding: 15px;
            border-left: 3px solid #00ffff;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        .channel-indicator { display: flex; align-items: center; margin-bottom: 6px; font-size: 13px; opacity: 0.5; transition: 0.2s; }
        .channel-indicator.active { opacity: 1; transform: translateX(5px); text-shadow: 0 0 8px currentColor; font-weight: bold; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 10px; background: currentColor; box-shadow: 0 0 5px currentColor; }
        
        #energy-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 400px; text-align: center;
        }
        #energy-bar-bg { width: 100%; height: 4px; background: #333; margin-top: 10px; position: relative; }
        #energy-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00ffff, #ff00ff); transition: width 0.1s linear; box-shadow: 0 0 10px #00ffff; }
        #bpm-display { font-size: 32px; font-weight: 100; text-shadow: 0 0 10px #00ffff; letter-spacing: 2px; }
        #status-msg { font-size: 12px; color: #aaa; margin-top: 5px; letter-spacing: 1px; }

        .hidden { display: none !important; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="hud-panel" class="hidden">
            <div style="margin-bottom:10px; font-size:12px; color:#ccc; border-bottom:1px solid #555; padding-bottom:5px;">CHANNEL STATUS</div>
            <div id="ch-thumb" class="channel-indicator" style="color: #666; opacity: 0.3;"><div class="dot"></div>DISABLED</div>
            <div id="ch-index" class="channel-indicator" style="color: #ffcc00"><div class="dot"></div>DRUM</div>
            <div id="ch-middle" class="channel-indicator" style="color: #00ff00"><div class="dot"></div>PIANO</div>
            <div id="ch-ring" class="channel-indicator" style="color: #00ffff"><div class="dot"></div>STRINGS</div>
            <div id="ch-pinky" class="channel-indicator" style="color: #aa00ff"><div class="dot"></div>WIND</div>
        </div>

        <div id="energy-container" class="hidden">
            <div id="bpm-display">0 BPM</div>
            <div id="energy-bar-bg"><div id="energy-bar-fill"></div></div>
            <div id="status-msg"></div>
        </div>

        <div id="start-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 100; cursor: pointer;">
            <div style="text-align: center; color: white;">
                <div style="font-size: 48px; margin-bottom: 20px;">ğŸµ</div>
                <div style="font-size: 24px; letter-spacing: 2px;">CLICK TO START</div>
            </div>
        </div>
    </div>

<script>
// ================= é…ç½®åŒºåŸŸ =================
const HISTORY_SIZE = 40;
const MIN_BPM = 60;
const MAX_BPM = 180;
const STOP_THRESHOLD = 0.005; 
const FINGER_COLORS = { thumb: 0xff00cc, index: 0xffcc00, middle: 0x00ff00, ring: 0x00ffff, pinky: 0xaa00ff };
const FINGER_MAP = [
    { name: 'thumb', tips: [1,2,3,4], color: FINGER_COLORS.thumb, id: 'ch-thumb' },
    { name: 'index', tips: [5,6,7,8], color: FINGER_COLORS.index, id: 'ch-index' },
    { name: 'middle', tips: [9,10,11,12], color: FINGER_COLORS.middle, id: 'ch-middle' },
    { name: 'ring', tips: [13,14,15,16], color: FINGER_COLORS.ring, id: 'ch-ring' },
    { name: 'pinky', tips: [17,18,19,20], color: FINGER_COLORS.pinky, id: 'ch-pinky' }
];

let currentState = 'IDLE';
let scene, camera, renderer;
let handMeshes = { left: null, right: null };
let channels = {};
let recorder, analyser, particleSystem;
let speedHistory = new Array(HISTORY_SIZE).fill(0);
let previousHandPositions = { left: null, right: null };
let fistHoldFrameCount = 0;

// æ‘„åƒæœº Z è½´è·ç¦» (ç”¨äºè®¡ç®—æŠ•å½±)
const CAM_Z = 8; 

// ================= 1. è§†å£è®¡ç®—å·¥å…· (æ ¸å¿ƒä¿®æ­£) =================
// è®¡ç®—åœ¨ç›¸æœºç‰¹å®š Z è½´æ·±åº¦ä¸‹ï¼Œå¯è§å¹³é¢çš„å®½å’Œé«˜
function getVisiblePlane(depth, camera) {
    // å‚ç›´è§†é‡è§’åº¦ (å¼§åº¦)
    const vFOV = camera.fov * Math.PI / 180; 
    // å¯è§é«˜åº¦ = 2 * tan(fov/2) * distance
    const height = 2 * Math.tan(vFOV / 2) * depth;
    const width = height * camera.aspect;
    return { width, height };
}

// ================= 2. Three.js éª¨éª¼ç±» =================
class Hand3D {
    constructor(scene) {
        this.scene = scene;
        this.joints = [];
        this.bones = [];
        
        const jointGeo = new THREE.SphereGeometry(0.12, 16, 16);
        for(let i=0; i<21; i++) {
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(jointGeo, mat);
            this.scene.add(mesh);
            this.joints.push(mesh);
        }
        
        const connections = [[0,1],[1,2],[2,3],[3,4], [0,5],[5,6],[6,7],[7,8], [0,9],[9,10],[10,11],[11,12], [0,13],[13,14],[14,15],[15,16], [0,17],[17,18],[18,19],[19,20], [5,9],[9,13],[13,17]];
        connections.forEach(pair => {
            const line = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]),
                new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, linewidth: 2 })
            );
            line.userData = { start: pair[0], end: pair[1] };
            this.scene.add(line);
            this.bones.push(line);
        });
    }

    update(landmarks) {
        // 1. è·å–å½“å‰è§†å¹³é¢å¤§å°ï¼Œç¡®ä¿ç²¾å‡†å¯¹é½
        const visible = getVisiblePlane(CAM_Z, camera);
        
        landmarks.forEach((lm, i) => {
            // ============ æ ¸å¿ƒä¿®æ­£é€»è¾‘ ============
            
            // Xè½´ï¼šé•œåƒç¿»è½¬
            // åŸç†ï¼šMediaPipe X (0å·¦ -> 1å³)ã€‚
            // è§†é¢‘ CSS ç¿»è½¬äº† (ScaleX -1)ï¼Œæ‰€ä»¥ç”¨æˆ·æŠŠæ‰‹æ”¾åˆ°å±å¹•å³ä¾§æ—¶ï¼Œ
            // æ‘„åƒå¤´åŸå§‹æ•°æ®å…¶å®æ˜¯å·¦ä¾§ (x=0.1)ã€‚
            // ä¸ºäº†è®© 3D ç‰©ä½“å‡ºç°åœ¨å±å¹•å³ä¾§ (+X)ï¼Œæˆ‘ä»¬éœ€è¦åå‘æ˜ å°„ã€‚
            // (0.5 - lm.x) ä½¿å¾—ï¼šå¦‚æœ x=0.1 (åŸå›¾å·¦)ï¼Œç»“æœä¸ºæ­£ (0.4)ï¼Œä¹˜ä»¥å®½åº¦åä½äºå³ä¾§ã€‚
            const x = (0.5 - lm.x) * visible.width;
            
            // Yè½´ï¼šæ ‡å‡†æ˜ å°„
            // MediaPipe Y (0ä¸Š -> 1ä¸‹)ã€‚
            // Three.js Y (æ­£ä¸Š -> è´Ÿä¸‹)ã€‚
            const y = (0.5 - lm.y) * visible.height;
            
            // Zè½´ï¼šæ·±åº¦ç¼©æ”¾
            // æ‰‹éƒ¨ Z åæ ‡æ¯”è¾ƒå°ï¼Œç¨å¾®æ”¾å¤§ä¸€ç‚¹è®©å‰åè¿åŠ¨æ›´æ˜æ˜¾
            const z = -lm.z * 15; 

            this.joints[i].position.set(x, y, z);
            this.joints[i].visible = true;
        });

        // æ›´æ–°éª¨éª¼çº¿
        this.bones.forEach(bone => {
            bone.geometry.setFromPoints([this.joints[bone.userData.start].position, this.joints[bone.userData.end].position]);
            bone.visible = true;
        });
        
        this.updateColors(landmarks);
    }

    updateColors(landmarks) {
        const wrist = landmarks[0];
        FINGER_MAP.forEach(f => {
            const tip = landmarks[f.tips[3]];
            const pip = landmarks[f.tips[1]];
            const distTip = Math.sqrt(Math.pow(tip.x-wrist.x,2)+Math.pow(tip.y-wrist.y,2));
            const distPip = Math.sqrt(Math.pow(pip.x-wrist.x,2)+Math.pow(pip.y-wrist.y,2));
            
            const isExtended = distTip > distPip + 0.05;
            const color = isExtended ? f.color : 0xffffff;
            const opacity = isExtended ? 1.0 : 0.2;

            f.tips.forEach(idx => {
                this.joints[idx].material.color.setHex(color);
                if(!isExtended) this.joints[idx].material.color.setHex(0xaaaaaa);
            });
            this.bones.forEach(b => {
                if (f.tips.includes(b.userData.end) && b.userData.end !== 0) {
                    b.material.color.setHex(color);
                    b.material.opacity = opacity;
                }
            });
        });
    }

    hide() { this.joints.forEach(j=>j.visible=false); this.bones.forEach(b=>b.visible=false); }
}

function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.z = CAM_Z; // å›ºå®šç›¸æœºè·ç¦»
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    
    handMeshes.left = new Hand3D(scene);
    handMeshes.right = new Hand3D(scene);

    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(0, 0, 10);
    scene.add(light);

    // çª—å£å¤§å°è°ƒæ•´æ—¶æ›´æ–°
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// ================= 3. éŸ³é¢‘é€»è¾‘ (Tone.js) =================
async function initAudio() {
    await Tone.start();
    recorder = new Tone.Recorder();

    // Load the 4 audio files
    channels.drum = new Tone.Player("https://github.com/yuanzhishan551-source/Conductor-/raw/main/1123398047-1-16_drum_split_by_lalalai.mp4").toDestination().connect(recorder);
    channels.piano = new Tone.Player("https://github.com/yuanzhishan551-source/Conductor-/raw/main/1123398047-1-16_piano_split_by_lalalai.mp3").toDestination().connect(recorder);
    channels.strings = new Tone.Player("https://github.com/yuanzhishan551-source/Conductor-/raw/main/1123398047-1-16_strings_split_by_lalalai.mp4").toDestination().connect(recorder);
    channels.wind = new Tone.Player("https://github.com/yuanzhishan551-source/Conductor-/raw/main/1123398047-1-16_wind_split_by_lalalai.mp4").toDestination().connect(recorder);

    // Set all players to loop
    channels.drum.loop = true;
    channels.piano.loop = true;
    channels.strings.loop = true;
    channels.wind.loop = true;

    // Start with all volumes at -Infinity
    channels.drum.volume.value = -Infinity;
    channels.piano.volume.value = -Infinity;
    channels.strings.volume.value = -Infinity;
    channels.wind.volume.value = -Infinity;

    Tone.Destination.volume.value = -Infinity;

    // Wait for all players to load
    await Promise.all([Tone.loaded()]);

    // Start all players
    channels.drum.start();
    channels.piano.start();
    channels.strings.start();
    channels.wind.start();
}

// ================= 4. äº¤äº’å¤„ç† =================
function processConducting(results) {
    const hands = results.multiHandLandmarks;
    const handedness = results.multiHandedness;

    handMeshes.left.hide(); handMeshes.right.hide();
    let currentLeftPos = null, currentRightPos = null;

    if (hands.length > 0) {
        hands.forEach((lm, i) => {
            const label = handedness[i].label; // MediaPipe: "Left" or "Right"
            // å½“è§†é¢‘è¢«é•œåƒåï¼ŒMediaPipe è¯´çš„ "Right" æ‰‹åœ¨è§†è§‰ä¸Šä¼šå‡ºç°åœ¨å·¦è¾¹ã€‚
            // ä½†å› ä¸ºæˆ‘ä»¬ä¹Ÿç¿»è½¬äº†åæ ‡è®¡ç®—ï¼Œæ‰€ä»¥é€»è¾‘ä¸Šï¼š
            // label === 'Right' (MediaPipeè®¤ä¸ºçš„å³æ‰‹) -> å…¶å®å¯¹åº”ç”¨æˆ·çš„å·¦æ‰‹ (å¦‚æœç”¨æˆ·åƒç…§é•œå­ä¸€æ ·)
            // ä¸è¿‡ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ç›´æ¥æŠŠæ•°æ®å–‚ç»™ meshï¼Œè®© update() å‡½æ•°é‡Œçš„åæ ‡å˜æ¢å»å¤„ç†ä½ç½®ã€‚
            
            if (label === 'Right') {
                handMeshes.right.update(lm);
                currentRightPos = lm[0];
            } else {
                handMeshes.left.update(lm);
                currentLeftPos = lm[0];
            }
        });
    }

    calculateDynamics(currentLeftPos, currentRightPos);
    updateChannelSwitches(hands);
    checkStopGesture(hands);
}

function calculateDynamics(leftPos, rightPos) {
    let movement = 0;
    // è®¡ç®—è·ç¦»éœ€è¦è€ƒè™‘åæ ‡ç³»ï¼Œè¿™é‡Œç®€å•ç”¨æ¬§æ°è·ç¦»ï¼Œå› ä¸ºæ˜¯å½’ä¸€åŒ–çš„æ‰€ä»¥æ•°å€¼è¾ƒå°
    if (leftPos && previousHandPositions.left) {
        movement += Math.hypot(leftPos.x - previousHandPositions.left.x, leftPos.y - previousHandPositions.left.y);
    }
    if (rightPos && previousHandPositions.right) {
        movement += Math.hypot(rightPos.x - previousHandPositions.right.x, rightPos.y - previousHandPositions.right.y);
    }
    previousHandPositions.left = leftPos;
    previousHandPositions.right = rightPos;

    speedHistory.push(movement);
    speedHistory.shift();
    const avgSpeed = speedHistory.reduce((a,b)=>a+b, 0) / HISTORY_SIZE;

    const energyBar = document.getElementById('energy-bar-fill');
    const bpmDisplay = document.getElementById('bpm-display');
    const statusMsg = document.getElementById('status-msg');

    if (avgSpeed < STOP_THRESHOLD) {
        Tone.Destination.volume.rampTo(-Infinity, 0.5);
        energyBar.style.width = "0%";
        energyBar.style.opacity = "0.2";
        bpmDisplay.innerText = "SILENCE";
        statusMsg.innerText = "";
    } else {
        if(Tone.Transport.state !== 'started') Tone.Transport.start();
        Tone.Destination.volume.rampTo(0, 0.1);
        
        const energy = Math.min((avgSpeed - STOP_THRESHOLD) * 25, 1);
        const targetBpm = MIN_BPM + (energy * (MAX_BPM - MIN_BPM));
        Tone.Transport.bpm.rampTo(targetBpm, 0.2);

        energyBar.style.width = `${energy*100}%`;
        energyBar.style.opacity = "1";
        bpmDisplay.innerText = `${Math.round(Tone.Transport.bpm.value)} BPM`;
        statusMsg.innerText = "CONDUCTING...";
    }
}

function updateChannelSwitches(hands) {
    let status = { thumb: false, index: false, middle: false, ring: false, pinky: false };
    hands.forEach(lm => {
        const wrist = lm[0];
        FINGER_MAP.forEach(f => {
            const tip = lm[f.tips[3]];
            const pip = lm[f.tips[1]];
            const distTip = Math.hypot(tip.x-wrist.x, tip.y-wrist.y);
            const distPip = Math.hypot(pip.x-wrist.x, pip.y-wrist.y);
            if (distTip > distPip + 0.05) status[f.name] = true;
        });
    });

    const t = 0.1;
    // Thumb is disabled, only 4 fingers control the 4 audio tracks
    // index -> drum, middle -> piano, ring -> strings, pinky -> wind
    channels.drum.volume.rampTo(status.index ? 0 : -Infinity, t);
    channels.piano.volume.rampTo(status.middle ? 0 : -Infinity, t);
    channels.strings.volume.rampTo(status.ring ? 0 : -Infinity, t);
    channels.wind.volume.rampTo(status.pinky ? 0 : -Infinity, t);

    FINGER_MAP.forEach(f => {
        const el = document.getElementById(f.id);
        if(status[f.name]) el.classList.add('active'); else el.classList.remove('active');
    });
}

function checkStopGesture(hands) {
    if (hands.length === 1) {
        const wrist = hands[0][0];
        let folded = 0;
        [8,12,16,20].forEach(i => {
            const d = Math.hypot(hands[0][i].x-wrist.x, hands[0][i].y-wrist.y);
            if (d < 0.15) folded++;
        });
        if (folded >= 4) {
            fistHoldFrameCount++;
            document.getElementById('status-msg').innerText = `HOLD TO UNIVERSE... ${Math.floor(fistHoldFrameCount/60*100)}%`;
            document.getElementById('status-msg').style.color = "#ff0055";
            if (fistHoldFrameCount > 60) finishPerformance();
        } else {
            fistHoldFrameCount = 0;
            document.getElementById('status-msg').style.color = "#aaa";
        }
    }
}

async function finishPerformance() {
    currentState = 'VISUALIZING';
    document.getElementById('hud-panel').classList.add('hidden');
    document.getElementById('energy-container').classList.add('hidden');
    
    // æ·¡å‡ºè§†é¢‘
    document.getElementById('video-element').style.opacity = '0';
    setTimeout(() => { document.getElementById('video-element').style.display = 'none'; }, 1000);

    Tone.Transport.stop();
    const blob = await recorder.stop();
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a'); a.href = url; a.download = 'noir_symphony.webm'; a.click();

    const player = new Tone.Player(url).toDestination();
    player.autostart = true; player.loop = true;
    analyser = new Tone.Analyser("fft", 1024);
    player.connect(analyser);

    createCosmos();
}

function createCosmos() {
    handMeshes.left.hide(); handMeshes.right.hide();
    renderer.setClearColor(0x000000, 1); // æ¢å¤é»‘èƒŒæ™¯

    const count = 30000;
    const geo = new THREE.BufferGeometry();
    const pos = []; const col = [];
    const c1 = new THREE.Color(0x00ffff), c2 = new THREE.Color(0xff00ff);

    for(let i=0; i<count; i++) {
        let x = Math.random()*50-25;
        let y = Math.random()*50-25;
        let z = Math.random()*50-25;
        pos.push(x,y,z);
        const dist = Math.sqrt(x*x+y*y+z*z);
        const mixed = c1.clone().lerp(c2, dist/30);
        col.push(mixed.r, mixed.g, mixed.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
    
    const mat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
    particleSystem = new THREE.Points(geo, mat);
    scene.add(particleSystem);
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(processConducting);

function animate() {
    requestAnimationFrame(animate);
    if (currentState === 'VISUALIZING' && particleSystem) {
        particleSystem.rotation.y += 0.002;
        const val = analyser.getValue()[10];
        const scale = 1 + (val+100)/150;
        particleSystem.scale.setScalar(scale);
    }
    renderer.render(scene, camera);
}

// Click to start
document.getElementById('start-overlay').addEventListener('click', async () => {
    document.getElementById('start-overlay').style.display = 'none';
    document.getElementById('hud-panel').classList.remove('hidden');
    document.getElementById('energy-container').classList.remove('hidden');

    initThree();
    await initAudio();

    const video = document.getElementById('video-element');
    const cam = new Camera(video, {
        onFrame: async () => await hands.send({image: video}),
        width: 1280, height: 720
    });
    cam.start();
    recorder.start();
    currentState = 'CONDUCTING';
    animate();
});
</script>
</body>
</html>
